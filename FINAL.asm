DB7      EQU P1.7
DB6      EQU P1.6
DB5      EQU P1.5
DB4      EQU P1.4
RS       EQU P1.3
EN       EQU P1.2 ; P1.1, P1.0 NOT USED // R/W' IS GROUNDED
MTRSNS   EQU P3.5 ; THE SENSOR FOR MOTOR (DATA SHEET OF https://www.edsim51.com/simInstructions.html#motor)
MTRA     EQU P3.1
MTRB     EQU P3.0
DOORSNS  EQU P2.0     

;USE SYSTEM CLOCK=11.0592MHz
;USE UPDATE FREQ=100


ORG 0000H

MOV 60H, #00001011B
MOV 61H, #00001011B
MOV 62H, #00001011B
MOV 63H, #00001011B ; DEFAULT PASS = 1111
CALL DISPLAYMODE ; 4BITINILIZATION

MOV A, #00000110B ; ENTRY INILIZATION SET(DISPLAY DATA SHEET PAGE 24)
CALL INSTRUCTIONFX

MOV A, #00001111B ; 1110, TURNS ON DISPLAY AND CURSOR AND BLINKING IS TURN ON (DISPLAY DATA SHEET PAGE 24)
CALL INSTRUCTIONFX

;----------------------------------------MAINFX---------------------------------------------

CLR MTRA
CLR MTRB
SETB MTRA ; MOVE MOTOR TO ORIGINAL POSITION MARKED BY THE MTRSNS
JB MTRSNS, $
CLR MTRA

MOV A, #'W'
CALL WRITEFX ; WRITEFX USE C REGISTER AND ACCUMULATOR
MOV A, #'E' ; 45H = 69dec = 0100 0101
CALL WRITEFX
MOV A, #'L'
CALL WRITEFX
MOV A, #'C'
CALL WRITEFX
MOV A, #'O'
CALL WRITEFX
MOV A, #'M'
CALL WRITEFX
MOV A, #'E'
CALL WRITEFX
CALL DELAY_100u
CALL DELAY_100u

MOV A, #01H
CALL INSTRUCTIONFX
CALL DELAY_1m

INITIALIZATIONFX:
JNB P2.0, OVERRIDE ;MOVE THE MOTOR CLOCKWISE AS IF TO LOCK THE DOOR
SETB MTRB
CALL DELAY_10u
JB MTRSNS, $
CLR MTRB

OVERRIDE:
MOV A, #01H
CALL INSTRUCTIONFX
CALL DELAY_1m
CALL DELAY_1m

MOV A, #'C'
CALL WRITEFX
MOV A, #'H'
CALL WRITEFX
MOV A, #'O'
CALL WRITEFX
MOV A, #'O'
CALL WRITEFX
MOV A, #'S'
CALL WRITEFX
MOV A, #'E'
CALL WRITEFX
MOV A, #' '
CALL WRITEFX
MOV A, #'F'
CALL WRITEFX ; WRITEFX USE C REGISTER AND ACCUMULATOR
MOV A, #'U' ; 45H = 69dec = 0100 0101
CALL WRITEFX
MOV A, #'N'
CALL WRITEFX
MOV A, #'C'
CALL WRITEFX
MOV A, #'T'
CALL WRITEFX
MOV A, #'I'
CALL WRITEFX
MOV A, #'O'
CALL WRITEFX
MOV A, #'N'
CALL WRITEFX

MOV A, #0C0H
CALL INSTRUCTIONFX
CALL DELAY_1m


CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0 (SEE https://www.edsim51.com/examples.html#prog7)
MOV C, P0.4 ; READING THE INPUT OF THE KEYPAD AND CHECKING TRUE OR NOT
MOV B.0, C
CPL B.0
MOV C, P0.0
MOV B.1, C
CPL B.1
CALL ANDLFX ; TAKE INPUT B.0, B.1 AND OUTPUT AT A USING R7 AS TEMPORARY RAM
JB ACC.0, LAUTHENTICATIONFX ;IF ACC.0 =1 GO TO AUTHENTICATIONFX
MOV C, P0.6 ; READING THE INPUT OF THE KEYPAD AND CHECKING TRUE OR NOT
MOV B.0, C
CPL B.0
MOV C, P0.0
MOV B.1, C
CPL B.1
CALL ANDLFX ; TAKE INPUT B.0, B.1 AND OUTPUT AT A USING R7 AS TEMPORARY RAM
JB ACC.0, LPASSCHGFX ; IF ACC.0 =1 GO TO PASSCHGFX
JNB ACC.0, INITIALIZATIONFX ; ELSE GO TO LABEL HERE
JMP INITIALIZATIONFX
CALL END

LPASSCHGFX:
LJMP PASSCHGFX
RET
LAUTHENTICATIONFX:
LJMP AUTHENTICATIONFX
RET


AUTHENTICATIONFX:
CALL R0_ASCIIFX ; DECODE R0 TO ASCII
MOV A, R0 ; ASCII FOR # = 23H, 00100011B
CALL WRITEFX ; WRITING CHARACTER TO THE LCD
MOV A, #'A'
CALL WRITEFX
MOV A, #'U'
CALL WRITEFX
MOV A, #'T'
CALL WRITEFX
MOV A, #'H'
CALL WRITEFX
MOV A, #'E'
CALL WRITEFX
MOV A, #'N'
CALL WRITEFX
MOV A, #'T'
CALL WRITEFX
MOV A, #'I'
CALL WRITEFX
MOV A, #'C'
CALL WRITEFX
MOV A, #'A'
CALL WRITEFX
MOV A, #'T'
CALL WRITEFX
MOV A, #'I'
CALL WRITEFX
MOV A, #'O'
CALL WRITEFX
MOV A, #'N'
CALL WRITEFX

CALL DELAY_1m
MOV A, #01H ;BIN CODE TO CLEAR SCREEN
CALL INSTRUCTIONFX
CALL DELAY_1m


CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, 60H, ; FETCHING DATA FROM ROM/(CODED RAM) TO STORE IN A, IS 60H GENERAL PURPOSE RAM?
CALL XRLFX ;INPUT R0=KEYPADFX 'AND' A=0BH OUTPUTS A
MOV R7, A ;TRU = FFH ELSE 00H
MOV A, #'*'
CALL WRITEFX

CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, 61H, ; FETCHING DATA FROM ROM/(CODED RAM) TO STORE IN A, IS 60H GENERAL PURPOSE RAM?
CALL XRLFX
MOV R6, A
MOV A, #'*'
CALL WRITEFX

CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, 62H, ; FETCHING DATA FROM ROM/(CODED RAM) TO STORE IN A, IS 60H GENERAL PURPOSE RAM?
CALL XRLFX
MOV  R5, A
MOV A, #'*'
CALL WRITEFX

CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, 63H, ; FETCHING DATA FROM ROM/(CODED RAM) TO STORE IN A, IS 60H GENERAL PURPOSE RAM?
CALL XRLFX ; IF TRUE RETURN 0FFH TO A IF FALSE RETURN 00H
MOV R4, A
MOV A, #'*'
CALL WRITEFX

MOV A, R7 ; R7=BH
MOV R0, A
CALL R0SECURITYCHK
JNB ACC.0, LJUMPINILIZATIONFX ; JUMP WHEN ACC.0 EQUAL ZERO
MOV A, R6 ; R6 =AH
MOV R0, A
CALL R0SECURITYCHK
JNB ACC.0, LJUMPINILIZATIONFX
MOV A, R5 ; R5=9H
MOV R0, A
CALL R0SECURITYCHK
JNB ACC.0, LJUMPINILIZATIONFX
MOV A, R4 ; R4=8H
MOV R0, A
CALL R0SECURITYCHK
JNB ACC.0, LJUMPINILIZATIONFX

MOV A, #01H
CALL INSTRUCTIONFX
CALL DELAY_1m
CALL DELAY_1m

CLR MTRA 
CLR MTRB ; COUNTER CLOCKWISE WHEN B = 1
SETB MTRA ; MOVE THE MOTOR COUNTER CLOCKWISE AS IF UNLOCK THE DOOR
CALL DELAY_10u
JB MTRSNS, $
CLR MTRA

MOV A, #'A'
CALL WRITEFX
MOV A, #'C'
CALL WRITEFX
MOV A, #'C'
CALL WRITEFX
MOV A, #'E'
CALL WRITEFX
MOV A, #'S'
CALL WRITEFX
MOV A, #'S'
CALL WRITEFX
MOV A, #' '
CALL WRITEFX
MOV A, #'G'
CALL WRITEFX
MOV A, #'R'
CALL WRITEFX
MOV A, #'A'
CALL WRITEFX
MOV A, #'N'
CALL WRITEFX
MOV A, #'T'
CALL WRITEFX
MOV A, #'E'
CALL WRITEFX
MOV A, #'D'
CALL WRITEFX


CALL DELAY_1m
CALL DELAY_1m
CALL DELAY_1m
CALL DELAY_1m
CALL DELAY_1m
JMP LJUMPINILIZATIONFXX
CALL END 

LJUMPINILIZATIONFX:
   MOV A, #0C0H
   CALL INSTRUCTIONFX
   CALL DELAY_1m
   MOV A, #'A'
   CALL WRITEFX
   MOV A, #'C'
   CALL WRITEFX
   MOV A, #'C'
   CALL WRITEFX
   MOV A, #'E'
   CALL WRITEFX
   MOV A, #'S'
   CALL WRITEFX
   MOV A, #'S'
   CALL WRITEFX
   MOV A, #' '
   CALL WRITEFX
   MOV A, #'D'
   CALL WRITEFX
   MOV A, #'E'
   CALL WRITEFX
   MOV A, #'N'
   CALL WRITEFX
   MOV A, #'I'
   CALL WRITEFX
   MOV A, #'E'
   CALL WRITEFX
   MOV A, #'D'
   CALL WRITEFX
   LJMP INITIALIZATIONFX
RET
; ---------------------------------END OF AUTH FUNC.----------------------------------


PASSCHGFX:
CALL R0_ASCIIFX ; DECODE R0 TO ASCII
MOV A, R0 ; ASCII FOR # = 23H, 00100011B
CALL WRITEFX ; WRITING CHARACTER TO THE LCD
MOV A, #'P'
CALL WRITEFX
MOV A, #'A'
CALL WRITEFX
MOV A, #'S'
CALL WRITEFX
MOV A, #'S'
CALL WRITEFX
MOV A, #'C'
CALL WRITEFX
MOV A, #'O'
CALL WRITEFX
MOV A, #'D'
CALL WRITEFX
MOV A, #'E'
CALL WRITEFX
MOV A, #' '
CALL WRITEFX
MOV A, #'C'
CALL WRITEFX
MOV A, #'H'
CALL WRITEFX
MOV A, #'A'
CALL WRITEFX
MOV A, #'N'
CALL WRITEFX
MOV A, #'G'
CALL WRITEFX
MOV A, #'E'
CALL WRITEFX

CALL DELAY_1m
MOV A, #01H
CALL INSTRUCTIONFX ; CLEAR SCREEN
CALL DELAY_1m
CALL DELAY_1m

CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, 60H, ; FETCHING DATA FROM ROM/(CODED RAM) TO STORE IN A, IS 60H GENERAL PURPOSE RAM?
CALL XRLFX ;INPUT R0=KEYPADFX 'AND' A=0BH OUTPUTS A
MOV R7, A
MOV A, #'*'
CALL WRITEFX

CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, 61H, ; FETCHING DATA FROM ROM/(CODED RAM) TO STORE IN A, IS 60H GENERAL PURPOSE RAM?
CALL XRLFX ;INPUT R0=KEYPADFX 'AND' A=0BH OUTPUTS A
MOV R6, A
MOV A, #'*'
CALL WRITEFX

CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, 62H, ; FETCHING DATA FROM ROM/(CODED RAM) TO STORE IN A, IS 60H GENERAL PURPOSE RAM?
CALL XRLFX ;INPUT R0=KEYPADFX 'AND' A=0BH OUTPUTS A
MOV  R5, A
MOV A, #'*'
CALL WRITEFX

CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, 63H, ; FETCHING DATA FROM ROM/(CODED RAM) TO STORE IN A, IS 60H GENERAL PURPOSE RAM?
CALL XRLFX ; IF TRUE RETURN FFH TO A IF FALSE RETURN 00H
MOV R4, A
MOV A, #'*'
CALL WRITEFX

MOV A, R7 ; R7=BH
MOV R0, A
CALL R0SECURITYCHK
JNB ACC.0, LJUMPINILIZATIONFXX ; JUMP WHEN ACC.0 EQUAL ZERO
MOV A, R6 ; R6 =AH
MOV R0, A
CALL R0SECURITYCHK
JNB ACC.0, LJUMPINILIZATIONFXX
MOV A, R5 ; R5=9H
MOV R0, A
CALL R0SECURITYCHK
JNB ACC.0, LJUMPINILIZATIONFXX
MOV A, R4 ; R4=8H
MOV R0, A
CALL R0SECURITYCHK
JNB ACC.0, LJUMPINILIZATIONFXX

MOV A, #01H
CALL INSTRUCTIONFX ; CLEAR SCREEN
CALL DELAY_1m
CALL DELAY_1m

;INSERTCODEHERE
CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, R0
MOV 60H, A
CALL R0_ASCIIFX
MOV A, R0
CALL WRITEFX

CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, R0
MOV 61H, A
CALL R0_ASCIIFX
MOV A, R0
CALL WRITEFX

CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, R0
MOV 62H, A
CALL R0_ASCIIFX
MOV A, R0
CALL WRITEFX

CALL KEYPADFX ; VALUE OF KEYPAD IS STORED IN R0
MOV A, R0
MOV 63H, A
CALL R0_ASCIIFX
MOV A, R0
CALL WRITEFX

JMP LJUMPINILIZATIONFXX
CALL END
LJUMPINILIZATIONFXX:
    LJMP INITIALIZATIONFX
RET
;-----------------------------------END OF PASSCHG FUNC.----------------------------------

;-----------------------------------END_OF_MAINFX-----------------------------------------    


DISPLAYMODE: ; 4 bit INILIZATION lcd
   CLR RS ; PIN RS=0 TO SEND AN INSTRUCTION RS=1 IF DATA BEING SENT
   MOV P1, #00100100B ; FUNCTION SET (CHECK DATA SHEET PG 24)

   SETB EN
   CLR EN ; NEGATIVE EDGE ON E

   CALL DELAY_100u ; WAIT FOR BUSY FLAG TO CLEAR

   SETB EN
   CLR EN ; NEGATIVE EDGE ON E

   MOV P1, #10000000B
   ;SETB P1.7 ; LOW NIBBLE SET

   SETB EN
   CLR EN

   CALL DELAY_100u
RET

INSTRUCTIONFX: ; FUNCTION TO SEND INSTRUCTION TO THE LCD MODULE
   CLR RS
   MOV C, ACC.7
   MOV P1.7, C
   MOV C, ACC.6
   MOV P1.6, C
   MOV C, ACC.5
   MOV P1.5, C
   MOV C, ACC.4
   MOV P1.4, C

   SETB EN
   CLR EN ;NEGATIVE EDGE ON E, TO SEND INSTRUCTION(S)

   MOV C, ACC.3
   MOV P1.7, C
   MOV C, ACC.2
   MOV P1.6, C
   MOV C, ACC.1
   MOV P1.5, C
   MOV C, ACC.0
   MOV P1.4, C

   SETB EN
   CLR EN

   CALL DELAY_100u
RET

WRITEFX: ; FUNCTION TO WRITE INTO LCD
   SETB P1.3 ; SET RS=1, INDICATE THAT DATA IS BEING SENT
   MOV C, ACC.7
   MOV DB7, C
   MOV C, ACC.6
   MOV DB6, C
   MOV C, ACC.5
   MOV DB5, C
   MOV C, ACC.4
   MOV DB4, C

   SETB EN
   CLR EN

   MOV C, ACC.3
   MOV DB7, C
   MOV C, ACC.2
   MOV DB6, C
   MOV C, ACC.1
   MOV DB5, C
   MOV C, ACC.0
   MOV DB4, C

   SETB EN
   CLR EN

   CALL DELAY_100u
RET


;------------------------------------------------DELAYFUNC------------------------------------

DELAY_10u: ;DELAYING 10us
   MOV R6, #05H
   DJNZ R6, $
RET

DELAY_100u: ;DELAYING 100us
	PUSH 00H
	MOV R0, #50
	DJNZ R0, $
	POP 00H
RET

DELAY_1m: ;DELAYING 1ms
   MOV R6, #0FAH
   MOV R7, #0FAH
   DJNZ R6, $ ; DJNZ USES 2C, EACH 1C = 1.085us
   DJNZ R7, $
RET

DELAY_500m:
   MOV R1, #0FAH
   DE1R1:
      MOV R6, #0FAH
      MOV R7, #0FAH
      DJNZ R6, $
      DJNZ R7, $
      DJNZ R1, DE1R1
      MOV R2, #0FAH
   DE1R2:
      MOV R6, #0FAH
      MOV R7, #0FAH
      DJNZ R6, $
      DJNZ R7, $
      DJNZ R2, DE1R2
RET

;--------------------KEYPAD INTERRUPT-------------------

KEYPADFX:
   MOV R0, #00H
   MOV P0, #11111111B ;RESETTING THE KEYPAD TO ORIGINAL HIGH POSITION
   ;SCAN ROW0
   SETB P0.3 ; SET HIGH ROW 3 ON KEYPAD (https://www.edsim51.com/examples.html#prog7)
   CLR P0.0
   JNB P0.4, GOTKEYFX ;COL 0 , JUMP IF BIT=0
   INC R0
   JNB  P0.5, GOTKEYFX ;COL 1
   INC R0
   JNB P0.6, GOTKEYFX ;COL 2
   INC R0
   
   ;SCAN ROW1
   SETB P0.0 ; SET HIGH ROW 0 ON KEYPAD
   CLR P0.1 
   JNB P0.4, GOTKEYFX
   INC R0
   JNB P0.5, GOTKEYFX
   INC R0
   JNB P0.6, GOTKEYFX
   INC R0

   ;SCAN ROW2
   SETB P0.1 ; SET HIGH ROW 1 ON KEYPAD
   CLR P0.2
   JNB P0.4, GOTKEYFX
   INC R0
   JNB P0.5, GOTKEYFX
   INC R0
   JNB P0.6, GOTKEYFX
   INC R0

   ;SCAN ROW3
   SETB P0.2 ;SET HIGH ROW 2 ON KEYPAD
   CLR P0.3
   JNB P0.4, GOTKEYFX
   INC R0
   JNB P0.5, GOTKEYFX
   INC R0
   JNB P0.6, GOTKEYFX
   INC R0


   JMP KEYPADFX ;JUMP BACK TO FRONT
   GOTKEYFX:
   SETB F0
RET

R0SECURITYCHK: ;
    CHK00:
        CJNE R0, #00H, CHK11 ; COMPARE R0 = 0
        MOV A, R0
        RET
    CHK11:
        CJNE R0, #0FFH, CHK00 ; COMPARE R0 = 1
        MOV A, R0
        RET
RET

R0_ASCIIFX: ;REPROGRAM THE R0 TO ASCII CODES
   CHK0:
      CJNE R0, #00H, CHK1 ; COMPARE R0 = 0
      MOV R0, #23H
      RET
   CHK1:
      CJNE R0, #01H, CHK2 ; COMPARE R0 = 1
      MOV R0, #30H
      RET
   CHK2:
      CJNE R0, #02H, CHK3 ; COMPARE R0 = 2
      MOV R0, #2AH
      RET
   CHK3:
      CJNE R0, #03H, CHK4 ; COMPARE R0 = 3
      MOV R0, #39H
      RET
   CHK4:
      CJNE R0, #04H, CHK5 ; COMPARE R0 = 4
      MOV R0, #38H
      RET
   CHK5:
      CJNE R0, #05H, CHK6 ; COMPARE R0 = 5
      MOV R0, #37H
      RET
   CHK6:
      CJNE R0, #06H, CHK7 ; COMPARE R0 = 6
      MOV R0, #36H
      RET
   CHK7:
      CJNE R0, #07H, CHK8 ; COMPARE R0 = 7
      MOV R0, #35H
      RET
   CHK8:
      CJNE R0, #08H, CHK9 ; COMPARE R0 = 8
      MOV R0, #34H
      RET
   CHK9:
      CJNE R0, #09H, CHKA ; COMPARE R0 = 9
      MOV R0, #33H
      RET
   CHKA:
      CJNE R0, #0AH, CHKB ; COMPARE R0 = 10
      MOV R0, #32H
      RET
   CHKB:
      CJNE R0, #0BH, CHK0 ; COMPARE R0 = 11
      MOV R0, #31H
      RET
RET

ANDLFX:
   MOV A, #00H
   MOV C, B.0
   MOV ACC.0, C
   MOV R7, A
   MOV C, B.1
   MOV ACC.0, C
   ANL A, R7 ; OUTPUTS AT A
RET

XRLFX:
   XRL A, R0 ; A= 00001011 R0 = 00001011
   JB ACC.0, ZERO
   JB ACC.1, ZERO
   JB ACC.2, ZERO
   JB ACC.3, ZERO
   MOV A, #0FFH
   RET
   ZERO:
   MOV A, #00H
   RET
RET











END:
   SJMP $
RET
